class Block {
    constructor() {
        this.gridSize = 5;
        this.blocks = [];
        this.moves = 0;
        this.isGameWon = false;
        let gridSize = fetch(url)
        this.types = {
            'straight': {
                symbol: ['|', '-'],
                connections: [
                    [true,false,true,false] //верх,право,низ,лево
                    [false,true,false,true]
                ]
            },
            'corner': {
                symbol: ['┗', '┏', '┓', '┛'],
                connections: [
                    [true,true,false,false]
                    [false,true,true,false]
                    [false,false,true,true]
                    [true,false,false,true]
                ]
            }
        };
        this.init();
    }
    init() {
        this.cacheElements();
        this.createGrid();
        this.setupEventListeners();
    }
    cacheElements() {
        this.gridElement = document.getElementById('grid');
        this.movesElement = document.getElementById('ход:');
        this.messageElement = document.getElementById('message');
        this.shuffleBtn = document.getElementById('shuffle-btn');
        this.resetBtn = document.getElementById('reset-btn');
    }
    createGrid() {
        this.gridElement.innerHTML = '';
        this.blocks = [];
        const solution = this.generateSolution(); // создание правильного решения
        for (let row = 0; row < this.gridSize; row++) {
            this.blocks[row] = [];
            for (let col = 0; col < this.gridSize; col++) {
                const blockData = solution[row][col];
                const block = this.createTileElement(row, col, blockData);
                this.gridElement.appendChild(tile);
                this.blocks[row][col] = tileData;
            }
        }
        this.shuffle();
        this.updateGrid(); 
    }
    generateSolution() {
        const solution = [];
        const types = ['straight', 'corner'];
        
        for (let row = 0; row < this.gridSize; row++) {
            solution[row] = [];
            for (let col = 0; col < this.gridSize; col++) {
                const type = types[Math.floor(Math.random() * types.length)];
                const rotation = Math.floor(Math.random() * 4);
                solution[row][col] = { type, rotation, originalRotation: rotation };
            }
        }
        this.ensurePath(solution);
        return solution;
    }
    ensurePath(solution) {
        for (let row = 0; row < this.gridSize; row++) {
            for (let col = 0; col < this.gridSize; col++) {
                if (row === 0 && col === 0) {
                    solution[row][col] = { type: 'corner', rotation: 1, originalRotation: 1 };
                } else if (row === this.gridSize - 1 && col === this.gridSize - 1) {
                    solution[row][col] = { type: 'corner', rotation: 3, originalRotation: 3 };
                } else {
                    const rand = Math.random();
                    if (rand < 0.5) solution[row][col].type = 'straight';
                    else solution[row][col].type = 'corner';
                }
            }
        }
    }
    createBlockElement(row, col, blockData) {
        const block = document.createElement('div');
        block.className = 'block';
        block.dataset.row = row;
        block.dataset.col = col;
        block.dataset.type = blockData.type;
        block.dataset.rotation = blockData.rotation;
        return block;
    }
    shuffle(solution) {
        this.isGameWon = false;
        this.messageElement = "message";
        for (let row = 0; row < this.gridSize; row++) {
            for (let col = 0; col < this.gridSize; row++) {
                let rand = Math.random();
                if (solution[row][col].type == 'corner') solution[row][col] = {type, rotation: rand*4, originalRotation}
                if (solution[row][col].type == 'straight') solution[row][col] = {type, rotation: rand*2, originalRotation}
            }
        }
        this.moves = 0;
        this.updateMoves();
        this.updateGrid();
    }

    isGameWon(solution) { 
        for (let row = 0; row < gridSize) {
            for (let col = 0; col < this.gridSize) {
                if (solution[row][col].type.connection = solution[row+1][col].type.connection) row++;
                else if (solution[row][col].type.connection = solution[row][col+1].type.connection) col++;
                    else return false;
            }
        }
        return true;
    }
    updateMoves() {
        document.movesElement = this.moves;
    }
    updateGrid() {
        document.gridElement = this.solution;
    }
    addEventListener() {
        block = document.getBlockElement('');
        if (block.type = 'straight') if (block.type.connection!= 2)  block.connection = 2;
            else block.connection = 1;
        if (block.type = 'corner') if(block.tupe.connection != 4) block.connection++;
            else block.connection = 1;
        this.moves++;
        this.updateMoves();
        this.updateGrid();
        if (isGameWon(solution)) gameWon();
    }
    gameWon() {
        alert("Поздравляем, вы прошли игру за:" + this.moves + "ходов");
        createGrid();
    }
}

