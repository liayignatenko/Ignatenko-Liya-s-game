class BlockGame {
    constructor() {
        this.gridSize = 5;
        this.blocks = [];
        this.moves = 0;
        this.originalBlocks = [];
        this.isGameWon = false;
        let gridSize = fetch(url)
        this.blockTypes = {
            'straight': {
                symbol: ['|', '-'],
                connections: [
                    [true,false,true,false] //верх,право,низ,лево
                    [false,true,false,true]
                ]
            },
            'corner': {
                symbol: ['┗', '┏', '┓', '┛'],
                connections: [
                    [true,true,false,false]
                    [false,true,true,false]
                    [false,false,true,true]
                    [true,false,false,true]
                ]
            }
        };
        this.init();
    }
    init() {
        this.cacheElements();
        this.createGrid();
        this.setupEventListeners();
    }
    cacheElements() {
        this.gridElement = document.getElementById('grid');
        this.movesElement = document.getElementById('ход:');
        this.messageElement = document.getElementById('message');
        this.newGameBtn = document.getElementById('new-game-btn')
        this.shuffleBtn = document.getElementById('shuffle-btn');
        this.resetBtn = document.getElementById('reset-btn');
        this.hintBtn = document.getElementById('reset-btn');
    }
    createNewGame() {
        this.generateRandomLayout();
        this.saveOriginalState();
        this.updateGrid();
        this.moves = 0;
        this.isGameWon = false;
        this.updateMoves();
        this.hideMessage();
    }
    generateRandomLayout() {
        this.blocks = [];
        const types = ['straight', 'corner'];
        for (let row = 0; row < this.gridSize; row++) {
            this.blocks[row] = [];
            for (let col = 0; col < this.gridSize; col++) {
                const type = types[Math.floor(Math.random() * types.length)];
                const rotation = Math.floor(Math.random() *
                (type === 'straight' ? 2 : 4)); 
                //?
                this.blocks[row][col]= {
                    type,
                    rotation
                };
            }
        }
        this.ensureSolvable();
    }
    ensureSolvable() {
        // левый верхний блок:
        if (this.blocks[0][0].type !== 'corner' ) {
            this.blocks[0][0].type = 'corner';
            this.blocks[0][0].rotation = 1;
        }
        // правый нижний блок: 
        if (this.blocks[4][4].type !== 'corner') {
            this.blocks[4][4].type !== 'corner';
            this.blocks[4][4].rotation = 3;
        }
    }
    saveOriginalState() {
        this.originalBlocks = JSON.parse(JSON.stringify(this.blocks));
    }
    updateGrid() {
        this.gridElement.innerHTML = '';
        const solution = this.generateSolution(); 
        for (let row = 0; row < this.gridSize; row++) {
            for (let col = 0; col < this.gridSize; col++) {
                const block = this.createTileElement(row, col, blockData);
                this.gridElement.appendChild(tile);
            }
        }
        this.highlightConnections();
    }
    createBlockElement(row, col) {
        const blockData = this.blocks[row][col];
        const block = document.createElement('div');
        block.className = 'block';
        block.dataset.row = row;
        block.dataset.col = col;
        block.dataset.type = blockData.type;
        block.dataset.rotation = blockData.rotation;
        const typeInfo = this.blockTypes[blockData.type];
        block.textContent = typeInfo.symbol[blockData.rotation % typeInfo.symbol.length];
        return block;
    }
    rotateBlock(row, col) {
        if (this.isGameWon) return;
        const block = this.blocks[row][col];
        const typeInfo = this.blockTypes[block.type];
        block.rotation = (block.rotation + 1) % typeInfo.symbol.length;
        const blockElement = document.querySelector(`.tile[data-row="${row}"][data-col="${col}"]`);
        blockElement.textContent = typeInfo.symbol[block.rotation];
        blockElement.dataset.rotation = block.rotation;
        this.moves++;
        this.updateMoves();
        this.highlightConnections();
        this.checkWinCondition(); 
    }
    highlightConnections() {
        document.querySelectorAll('.block').forEach( block => {
            block.classList.remove('connected');
        })
        const visited = new Set();
        const stack = [[0,0]];

        while (stack.length > 0) {
            const [row, col] = stack.pop();
            const key = `${row},${col}`;
            if (visited.has(key)) continue;
            visited.add(key);
            const blockElement = document.querySelector(`.tile[data-row="${row}"][data-col="${col}"]`);
            blockElement.classList.add('connected');
            const neighbors = [
                {row: row-1, col: col, dirFrom: 0, dirTo: 2}, // Верх
                {row: row, col: col+1, dirFrom: 1, dirTo: 3}, // Право
                {row: row+1, col: col, dirFrom: 2, dirTo: 0}, // Низ
                {row: row, col: col-1, dirFrom: 3, dirTo: 1}//лево
            ];
            const blockData = this.block[row][col];
            const connections = this.blockData[blockData.type].connections[blockData.rotation];

            for ( const neighbor of neighbors) {
                if ((neighbor.row >= 0 && neighbor.row < this.gridSize) && (neighbor.col < gridSize && neighbor.col >= 0)) {
                    const neighborData = this.blocks[neighbor.row][neighbor.col];
                    const neighborConnections = this.blockTypes[neighborData.type].connections[neighborData.rotation];
                    if (connections[neighbor.dirFrom] && neighborConnections[neighbor.dirTo]) {
                        stack.push([nrow,ncol]); 
                    }
                }
            }
        }
    }
    checkWinCondition() {
        const connectedBlocks = document.querySelectorAll('.tile.connected').length;
        if (connectedBlocks === this.gridSize * this.gridSize) {
            this.winGame();
        }
    }

    winGame() {
        this.isGameWon = true;
        this.messageElement.textContent = `Поздравляем! Вы решили головоломку за ${this.moves} ходов!`;
        this.messageElement.className = 'message success';
        this.celebrate();
    }

    celebrate() {
        const blocks = document.querySelectorAll('.block');
        block.forEach((block,index) => {
            setTimeout(() => {
                block.style.animation = 'celebrate 0.5s ease';
                setTimeout(() => {
                    tile.style.animation = '';
                }, 500);
            }, index*30);
        });
    }

    updateMoves() {
        this.movesElement.textContent = this.moves;
    }

    shuffle() {
        if (this.isGameWon) return;
        for (let row = 0; row < this.gridSize; row++) {
            for (let col = 0; col < this.gridSize; col++) {
                const block = this.blocks[row][col].type;
                const typeInfo = this.blockTypes[block.type];
                block.rotation = Math.floor(Math.random() * typeInfo.symbol.length);
            }
        }
        this.moves++;
        this.updateMoves();
        this.updateGrid();
        this.hideMessage();
    }

    resetToOriginal() {
        this.blocks = JSON.parse(JSON.stringify(this.originalBlocks));
        this.moves = 0;
        this.isGameWon = false;
        this.updateMoves();
        this.updateGrid();
        this.hideMessage();
    }

    showHint() {
        if (this.isGameWon) return;
        for (let row = 0; row < this.gridSize; row++) {
            for (let col = 0; col < this.gridSize; col++) {
                const curRotation = this.blocks[row][col].rotation;
                const origRotation = this.originalBlocks[row][col].rotation;
                if (curRotation != origRotation ) {
                    const blockElement = document.querySelector(`.tile[data-row="${row}"][data-col="${col}"]`);
                    blockElement.style.animation = 'hint 1s infinite';
                    this.messageElement.textContent = `Блок [${row+1}, ${col+1}] нужно повернуть `;
                    this.messageElement.className = 'message error';
                    setTimeout(() => {
                        blockElement.style.animation = '';
                        this.hideMessage();
                    }, 3000);
                    return;
                }
            }
        }
        this.messageElement.textContent =  ` Все блоки правильно повернуты`;
        this.messageElement.className = 'message error';
        setTimeout(() => this.hideMessage(),2000);
    }

    hideMessage() {
        this.messageElement.className = 'message';
    }

    setupEventListener() {
        this.gridElement.addEventListener('click', (e) => {
            const tile = e.target.closest('.block');
            if (block) {
                const row = parseInt(block.dataset.row);
                const col = parseInt(block.dataset.col);
                this.rotateBlock(row,col);
            }
        });
        this.newGameBtn.addEventListener('click', () => {
            this.createNewGame();
        });
        this.shuffleBtn.addEventListener('click', () => {
            this.shuffle();
        });
        this.hintBtn.addEventListener('click', () => {
            this.showHint();
        });
        this.resetBtn.addEventListener('click', () => {
            this.resetToOriginal();
        });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'n' || e.key === 'т') {
                this.createNewGame();
            } else if (e.key === 'r' || e.key === 'к') {
                this.resetToOriginal();
            } else if (e.key === 'h' || e.key === 'р') {
                this.showHint();
            } else if (e.key === 's' || e.key === 'ы') {
                this.shuffle();
            }
        });
    }
}

const style = document.createElement('style');
style.textContent = `
   @keyframes celebrate {
    0% { transform: scale(1);}
    50% { transform: scale(1.2) rotate(10deg); background: gold; }
    100% { transform: scale(1)}
   }

   @keyframes hint {
    0% {box-shadow: 0 0 0px gold;}
    50% {box-shadow: 0 0 30px gold;}
    100% {box-shadow: 0 0 0px gold;}
   }
`;
document.head.appendChild(style);

window.addEventListener('DOMContentLoaded', () => {
    new BlockGame();
});



